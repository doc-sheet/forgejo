// Copyright 2022 The Gitea Authors. All rights reserved.
// Use of this source code is governed by a MIT-style
// license that can be found in the LICENSE file.

package i18n

import (
	"text/template"

	"code.gitea.io/gitea/modules/log"
	"code.gitea.io/gitea/modules/translation/i18n/plurals"
)

type locale struct {
	store       *localeStore
	langName    string
	idxToMsgMap map[int]string // the map idx is generated by store's trKeyToIdxMap

	tmpl *template.Template
}

func newLocale(store *localeStore, langName string) *locale {
	return &locale{store: store, langName: langName, idxToMsgMap: make(map[int]string), tmpl: &template.Template{}}
}

// Tr translates content to locale language. fall back to default language.
func (l *locale) Tr(trKey string, trArgs ...interface{}) string {
	format := trKey

	idx, ok := l.store.trKeyToIdxMap[trKey]
	if ok {
		if msg, ok := l.idxToMsgMap[idx]; ok {
			format = msg // use the found translation
		} else if def, ok := l.store.localeMap[l.store.defaultLang]; ok {
			// try to use default locale's translation
			if msg, ok := def.idxToMsgMap[idx]; ok {
				format = msg
			}
		}
	}
	return l.format(trKey, format, trArgs...)
}

func (l *locale) format(trKey, format string, trArgs ...interface{}) string {
	msg, err := Format(l, format, trArgs...)
	if err != nil {
		log.Error("Error whilst formatting %q in %s: %v", trKey, l.langName, err)
	}
	return msg
}

// Has returns whether a key is present in this locale or not
func (l *locale) Has(trKey string) bool {
	idx, ok := l.store.trKeyToIdxMap[trKey]
	if !ok {
		return false
	}
	_, ok = l.idxToMsgMap[idx]
	return ok
}

func (l *locale) TrOrdinal(cnt interface{}, trKey string, args ...interface{}) string {
	return l.trPlurals(cnt, plurals.DefaultRules.Ordinal(l.langName), trKey, args...)
}

func (l *locale) TrPlural(cnt interface{}, trKey string, args ...interface{}) string {
	return l.trPlurals(cnt, plurals.DefaultRules.Rule(l.langName), trKey, args...)
}

func (l *locale) TrPlurals(cnt interface{}, ruleType, trKey string, args ...interface{}) string {
	return l.trPlurals(cnt, plurals.DefaultRules.RuleByType(plurals.RuleType(ruleType), l.langName), trKey, args...)
}

func (l *locale) trPlurals(cnt interface{}, rule *plurals.Rule, trKey string, args ...interface{}) string {
	if rule == nil {
		// if we fail to parse fall back to the standard
		return l.Tr(trKey, args...)
	}

	operands, err := plurals.NewOperands(cnt)
	if err != nil {
		// if we fail to parse fall back to the standard
		return l.Tr(trKey, args...)
	}

	form := rule.PluralFormFunc(operands)

	// Now generate the pluralised key
	formKey := trKey + "_" + string(form)
	formIdx, formOk := l.store.trKeyToIdxMap[formKey]
	if formOk { // there are at least some locales that have a format for this key...
		msg, found := l.idxToMsgMap[formIdx]
		if found { // and our locale has this key
			return l.format(formKey, msg, args...)
		}
	}

	// Try falling back to the other form
	otherKey := trKey + "_" + string(plurals.Other)
	otherIdx, otherOk := l.store.trKeyToIdxMap[otherKey]
	if otherOk { // there are at least some locales that have a format for this key...
		msg, found := l.idxToMsgMap[otherIdx]
		if found { // and our locale has this key
			return l.format(formKey, msg, args...)
		}
	}

	// Try falling back to the trkey
	trIdx, trOk := l.store.trKeyToIdxMap[trKey]
	if trOk { // there are at least some locales that have a format for this key...
		msg, found := l.idxToMsgMap[trIdx]
		if found { // and our locale has this key
			return l.format(formKey, msg, args...)
		}
	}

	// Try falling back to the default language
	if def, ok := l.store.localeMap[l.store.defaultLang]; ok && def != l {
		if formOk {
			msg, found := def.idxToMsgMap[formIdx]
			if found { // the default locale has this key
				return def.format(formKey, msg, args...)
			}
		}
		if otherOk {
			msg, found := def.idxToMsgMap[otherIdx]
			if found { // the default locale has this key
				return def.format(formKey, msg, args...)
			}
		}
		if trOk {
			msg, found := def.idxToMsgMap[trIdx]
			if found { // the default locale has this key
				return def.format(formKey, msg, args...)
			}
		}
	}

	// OK we've tried really hard to handle this and we've got nowhere - just use the formKey string as the format
	return l.format(trKey, formKey, args...)
}
